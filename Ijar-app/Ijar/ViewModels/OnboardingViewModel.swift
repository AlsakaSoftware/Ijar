import Foundation
import SwiftUI

enum OnboardingStep: Int, CaseIterable {
    case welcome = 0
    case location = 1
    case rooms = 2
    case budget = 3
    case furnishing = 4
    case places = 5
    case notifications = 6
    case summary = 7
    case complete = 8

    var title: String {
        switch self {
        case .welcome: return "Welcome"
        case .location: return "Location"
        case .rooms: return "Rooms"
        case .budget: return "Budget"
        case .furnishing: return "Furnishing"
        case .places: return "Places"
        case .notifications: return "Notifications"
        case .summary: return "Summary"
        case .complete: return "Complete"
        }
    }
}

@MainActor
class OnboardingViewModel: ObservableObject {
    // MARK: - Step Navigation
    @Published var currentStep: OnboardingStep = .welcome
    @Published var isComplete = false
    @Published var isSubmitting = false
    @Published var submissionError: String?

    // MARK: - Location Step
    @Published var areaName = ""
    @Published var latitude: Double?
    @Published var longitude: Double?
    @Published var radius: Double = 1.0
    @Published var isGeocoding = false
    @Published var geocodingError: String?

    // MARK: - Rooms Step
    @Published var minBedrooms: Int?
    @Published var maxBedrooms: Int?
    @Published var minBathrooms: Int?
    @Published var maxBathrooms: Int?

    // MARK: - Budget Step
    @Published var minPrice: Int?
    @Published var maxPrice: Int?

    // MARK: - Furnishing Step
    @Published var furnishType: String?

    // MARK: - Guest Mode
    let isGuestMode: Bool

    // MARK: - Services
    private let geocodingService = GeocodingService()
    private let searchQueryService = SearchQueryService()
    private let liveSearchService = LiveSearchService()
    private var geocodingTask: Task<Void, Never>?

    init(isGuestMode: Bool = false) {
        self.isGuestMode = isGuestMode
    }

    // MARK: - Computed Properties

    var canProceedFromLocation: Bool {
        latitude != nil && longitude != nil && geocodingError == nil && !isGeocoding
    }

    var canProceedFromRooms: Bool {
        true // All fields optional
    }

    var canProceedFromBudget: Bool {
        true // All fields optional
    }

    var canProceedFromFurnishing: Bool {
        true // All fields optional
    }

    var canProceedFromPlaces: Bool {
        true // Optional step
    }

    var canProceed: Bool {
        switch currentStep {
        case .welcome: return true
        case .location: return canProceedFromLocation
        case .rooms: return canProceedFromRooms
        case .budget: return canProceedFromBudget
        case .furnishing: return canProceedFromFurnishing
        case .places: return canProceedFromPlaces
        case .summary, .notifications, .complete: return true
        }
    }

    var isFirstStep: Bool {
        currentStep == .welcome
    }

    var isLastStep: Bool {
        currentStep == .summary
    }

    var progressPercentage: Double {
        Double(currentStep.rawValue + 1) / Double(OnboardingStep.allCases.count)
    }

    // Auto-generated search name
    var autoGeneratedName: String {
        var parts: [String] = []

        // Get short area name (first part before comma)
        let shortArea = areaName.split(separator: ",").first.map(String.init) ?? areaName
        if !shortArea.isEmpty {
            parts.append(shortArea)
        }

        // Add bedroom info
        if let min = minBedrooms, let max = maxBedrooms, min == max {
            parts.append(min == 0 ? "Studio" : "\(min)-bed")
        } else if let min = minBedrooms {
            parts.append(min == 0 ? "Studio" : "\(min)+ bed")
        } else if let max = maxBedrooms {
            parts.append("Up to \(max)-bed")
        }

        return parts.isEmpty ? "My Search" : parts.joined(separator: " ")
    }

    // Summary display helpers
    var locationSummary: String {
        var text = areaName
        if radius > 0 {
            if radius == 0.5 {
                text += " (within ½ mile)"
            } else if radius == 1.0 {
                text += " (within 1 mile)"
            } else {
                text += " (within \(Int(radius)) miles)"
            }
        }
        return text
    }

    var roomsSummary: String {
        var parts: [String] = []

        // Bedrooms
        if let min = minBedrooms, let max = maxBedrooms {
            if min == max {
                parts.append(min == 0 ? "Studio" : "\(min) bedroom\(min == 1 ? "" : "s")")
            } else {
                let minText = min == 0 ? "Studio" : "\(min)"
                parts.append("\(minText)-\(max) bedrooms")
            }
        } else if let min = minBedrooms {
            parts.append(min == 0 ? "Studio" : "\(min)+ bedrooms")
        } else if let max = maxBedrooms {
            parts.append("Up to \(max) bedrooms")
        } else {
            parts.append("Any bedrooms")
        }

        // Bathrooms
        if let min = minBathrooms, let max = maxBathrooms {
            if min == max {
                parts.append("\(min) bathroom\(min == 1 ? "" : "s")")
            } else {
                parts.append("\(min)-\(max) bathrooms")
            }
        } else if let min = minBathrooms {
            parts.append("\(min)+ bathrooms")
        } else if let max = maxBathrooms {
            parts.append("Up to \(max) bathrooms")
        }

        return parts.joined(separator: ", ")
    }

    var budgetSummary: String {
        if let min = minPrice, let max = maxPrice {
            return "£\(min.formatted()) - £\(max.formatted()) pcm"
        } else if let min = minPrice {
            return "£\(min.formatted())+ pcm"
        } else if let max = maxPrice {
            return "Up to £\(max.formatted()) pcm"
        }
        return "Any budget"
    }

    var furnishingSummary: String {
        switch furnishType {
        case "furnished": return "Furnished"
        case "partFurnished": return "Part furnished"
        case "unfurnished": return "Unfurnished"
        default: return "Any"
        }
    }

    // MARK: - Navigation

    func goToNextStep() {
        guard let nextIndex = OnboardingStep(rawValue: currentStep.rawValue + 1) else { return }
        withAnimation(.easeInOut(duration: 0.3)) {
            currentStep = nextIndex
        }
    }

    func goToPreviousStep() {
        guard let prevIndex = OnboardingStep(rawValue: currentStep.rawValue - 1) else { return }
        withAnimation(.easeInOut(duration: 0.3)) {
            currentStep = prevIndex
        }
    }

    func goToStep(_ step: OnboardingStep) {
        withAnimation(.easeInOut(duration: 0.3)) {
            currentStep = step
        }
    }

    // MARK: - Geocoding

    func geocodeArea(_ area: String) {
        geocodingTask?.cancel()
        latitude = nil
        longitude = nil
        geocodingError = nil

        let trimmedArea = area.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedArea.isEmpty else { return }

        geocodingTask = Task {
            do {
                try await Task.sleep(nanoseconds: 500_000_000) // 0.5s debounce
                guard !Task.isCancelled else { return }

                isGeocoding = true

                let result = try await geocodingService.geocodeAreaToPostcode(trimmedArea)
                guard !Task.isCancelled else { return }

                isGeocoding = false
                latitude = result.latitude
                longitude = result.longitude
                geocodingError = nil

            } catch let error as GeocodingError {
                guard !Task.isCancelled else { return }
                isGeocoding = false
                latitude = nil
                longitude = nil
                geocodingError = error.localizedDescription
            } catch {
                guard !Task.isCancelled else { return }
                isGeocoding = false
                latitude = nil
                longitude = nil
                geocodingError = "Couldn't find this area"
            }
        }
    }

    // MARK: - Completion

    func completeOnboarding() async -> [Property] {
        guard let lat = latitude, let lng = longitude else {
            submissionError = "Please enter a valid location"
            return []
        }

        isSubmitting = true
        submissionError = nil

        // Create SearchQuery for API call (used for both guest and authenticated)
        let query = SearchQuery(
            name: autoGeneratedName,
            areaName: areaName.trimmingCharacters(in: .whitespacesAndNewlines),
            latitude: lat,
            longitude: lng,
            minPrice: minPrice,
            maxPrice: maxPrice,
            minBedrooms: minBedrooms,
            maxBedrooms: maxBedrooms,
            minBathrooms: minBathrooms,
            maxBathrooms: maxBathrooms,
            radius: radius,
            furnishType: furnishType
        )

        if isGuestMode {
            // Guest mode: Store preferences in memory, fetch properties but don't save to database
            GuestPreferencesStore.shared.setFromOnboarding(
                areaName: areaName.trimmingCharacters(in: .whitespacesAndNewlines),
                latitude: lat,
                longitude: lng,
                radius: radius,
                minBedrooms: minBedrooms,
                maxBedrooms: maxBedrooms,
                minBathrooms: minBathrooms,
                maxBathrooms: maxBathrooms,
                minPrice: minPrice,
                maxPrice: maxPrice,
                furnishType: furnishType
            )

            // Fetch properties using live search (doesn't save to Supabase)
            await liveSearchService.search(
                latitude: lat,
                longitude: lng,
                minPrice: minPrice,
                maxPrice: maxPrice,
                minBedrooms: minBedrooms,
                maxBedrooms: maxBedrooms,
                minBathrooms: minBathrooms,
                maxBathrooms: maxBathrooms,
                radius: radius,
                furnishType: furnishType
            )

            if let searchError = liveSearchService.error {
                print("Search warning: \(searchError)")
            }

            // Mark onboarding complete for guest
            UserDefaults.standard.set(true, forKey: UserDefaultsKeys.hasCompletedPreferencesOnboarding)

            isSubmitting = false
            isComplete = true

            return liveSearchService.properties
        }

        // Authenticated mode: Save query to database and fetch properties
        do {
            // Save query to Supabase
            let success = await searchQueryService.createQuery(query)
            guard success else {
                submissionError = searchQueryService.error ?? "Failed to save your search"
                isSubmitting = false
                return []
            }

            // Fetch initial properties using onboarding endpoint (saves to Supabase)
            await liveSearchService.onboardingSearch(queryId: query.id.uuidString, query: query)

            if let searchError = liveSearchService.error {
                // Still complete onboarding, but log the error
                print("Search warning: \(searchError)")
            }

            // Mark onboarding complete
            UserDefaults.standard.set(true, forKey: UserDefaultsKeys.hasCompletedPreferencesOnboarding)

            isSubmitting = false
            isComplete = true

            return liveSearchService.properties

        } catch {
            submissionError = error.localizedDescription
            isSubmitting = false
            return []
        }
    }
}
